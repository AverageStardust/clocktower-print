// @deno-types="https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.d.ts"
import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.mjs';
import * as path from "jsr:@std/path";
import { printError, printWarning } from './logging.ts';

enum TokenType {
    Character = "character",
    Reminder = "reminder"
}

export interface Config {
    script: Script<Token>;

    characterPrintRadius: number;
    characterCutRadius: number;

    reminderPrintRadius: number;
    reminderCutRadius: number;

    pageWidth: number;
    pageHeight: number;
    pageDpi: number;
}

export interface Script<T> {
    title: string;
    author: string;
    tokens: T[];
}

export interface Token {
    name: string;
    isOffical: boolean;
    characterImage: ImageBitmap;
    reminderImages: ImageBitmap[];
    characterCount: number;
    reminderCount: number;
}

interface ImageEntry {
    filename: string;
    searchName: string;
}

type ScriptSkeleton = Script<Partial<Token> & {
    name: string,
    isOffical: boolean
}>;
type ScriptSkeletonWithImages = Script<Partial<Token> & {
    name: string,
    isOffical: boolean,
    characterImage: ImageBitmap,
    reminderImages: ImageBitmap[];
}>;

const imageFileTypes = [".png"];
const fuseConfirmWithUserThreshold = 0.2;
const fuseOptions = {
    isCaseSensitive: false,
    includeScore: true,
    threshold: 0.45,
    keys: [
        "searchName",
    ]
};

const decoder = new TextDecoder();

export async function promptConfig(): Promise<Config> {
    const config: Partial<Config> = {};


    config.script = await promptScript();

    config.characterPrintRadius = 51.3;
    config.characterCutRadius = 45;

    config.reminderPrintRadius = 28;
    config.reminderCutRadius = 25;

    config.pageWidth = 210; // A4 width
    config.pageHeight = 279.4; // Letter paper height

    config.pageDpi = 300;

    return config as Config;
}

async function promptScript() {
    // repeat prompt until something is entered
    let filePath;
    do {
        filePath = prompt("Where is the script file:", "testScripts/Labyrinth.json");
    } while (filePath === null);

    // parse script
    let script: ScriptSkeleton;
    try {
        const bytes = await Deno.readFile(filePath);
        const text = decoder.decode(bytes);
        const json = JSON.parse(text);
        script = parseScript(json);
    } catch (err) {
        // error and try again
        printError(String(err));
        console.log(""); // add new line
        return promptScript();
    }

    console.log(""); // add new line

    // add token images
    await addScriptImages(script, TokenType.Character, "Where are the character images:", "testCharacters");
    await addScriptImages(script, TokenType.Reminder, "Where are the reminder images:", "testReminders");

    // print summary
    try {
        printSummary(script as ScriptSkeletonWithImages);
    } catch (err) {
        // error and try again
        printError(String(err));
        console.log(""); // add new line
        return promptScript();
    }

    // add token counts
    promptScriptCounts(script);

    return script as Script<Token>;
}

function parseScript(obj: unknown): ScriptSkeleton {
    const script: Partial<Script<Partial<Token>>> = {};
    script.tokens = [];

    if (!Array.isArray(obj))
        throw Error("Invalid script: script not an array");

    for (const tag of obj) {

        // handle weird format generated by ivory clocktower
        if (typeof tag == "string") {
            if (checkIfMagicString(tag)) continue;
            script.tokens.push({ name: tag, isOffical: true });
            continue;
        }

        if (typeof tag !== "object")
            throw Error("Invalid script: tag not a object");

        const id = tag.id;
        if (typeof id !== "string")
            throw Error("Invalid script: id is not a string");

        script.author = "unknown";
        script.title = "untitled";
        switch (id) {
            case "_meta":
                // parse meta tag
                if (typeof tag.author === "string")
                    script.author = tag.author
                if (typeof tag.name === "string")
                    script.title = tag.name

                break;
            default: {
                if (checkIfMagicString(id)) break;

                // parse token tag
                if (tag.name !== undefined) {
                    script.tokens.push({ name: String(tag.name), isOffical: false });
                } else {
                    // offical tokens will likely only have an id
                    script.tokens.push({ name: id, isOffical: true });
                }
            } break;
        }
    }

    if (script.tokens.length <= 0)
        printWarning("Warning: Zero tokens found in script");

    return script as ScriptSkeleton;
}

function checkIfMagicString(str: string) {
    if (str.startsWith("_")) {
        printWarning(`Warning: Unknown magic string "${str}"`);
        return true;
    }

    return false;
}

async function addScriptImages(script: ScriptSkeleton, tokenType: TokenType, message?: string, _default?: string) {
    // repeat prompt until something is entered
    let folderPath;
    do {
        folderPath = prompt(message, _default);
    } while (folderPath === null);
    console.log(""); // add new line

    const officalEntries: ImageEntry[] = [];
    const unofficalEntries: ImageEntry[] = [];
    const unknownEntries: ImageEntry[] = [];

    // search for files in folder
    try {
        for await (const dirEntry of Deno.readDir(folderPath)) {
            if (!dirEntry.isFile) continue;

            const searchName = dirEntry.name.split(".")[0].split("_")[0];
            const fileType = path.extname(dirEntry.name);
            const isImage = imageFileTypes.includes(fileType.toLowerCase());

            if (!isImage) continue;

            const entry: ImageEntry = {
                filename: dirEntry.name,
                searchName
            };
            if (name.toLowerCase().includes("unofficial")) {
                unofficalEntries.push(entry);
            } else if (name.toLowerCase().includes("official")) {
                officalEntries.push(entry);
            } else {
                unknownEntries.push(entry);
            }
        }
    } catch (err) {
        // error and try again
        printError(String(err));
        console.log(""); // add new line
        return await addScriptImages(script, tokenType, message, _default);
    }

    if (unknownEntries.length > 0) {
        // only warn if some things are labeled, if nothing is labeled we will just suffer
        if (officalEntries.length > 0 || unofficalEntries.length > 0)
            console.warn(`Some ${tokenType} images have not been labels official/unoffical`);

        officalEntries.push(...unknownEntries);
        unofficalEntries.push(...unknownEntries);
    }

    const officalFuse = new Fuse(officalEntries, fuseOptions);
    const unofficalFuse = new Fuse(unofficalEntries, fuseOptions);

    for (const token of script.tokens) {
        const fuse = token.isOffical ? officalFuse : unofficalFuse;

        let entries: ImageEntry[];
        switch (tokenType) {
            case TokenType.Character:
                entries = [searchForCharacterImage(fuse, token.name)];
                break;
            case TokenType.Reminder:
                entries = searchForReminderImages(fuse, token.name);
                break;
        }

        const filePaths = entries.map(entry => path.join(folderPath, entry.filename));
        const images = await Promise.all(filePaths.map(loadImage));

        switch (tokenType) {
            case TokenType.Character:
                token.characterImage = images[0];
                break;
            case TokenType.Reminder:
                token.reminderImages = images;
                break;
        }
    }
}

function searchForCharacterImage(fuse: Fuse<ImageEntry>, tokenName: string): ImageEntry {
    const searchResults = fuse.search(tokenName, { limit: 5 });

    for (let i = 0; i < searchResults.length; i++) {
        const result = searchResults[i];

        // check if result needs to be confirmed by the user
        if ((result.score ?? 0) < fuseConfirmWithUserThreshold) {
            return result.item; // safe match
        } else {
            // confirm with user on dubious matches
            if (confirm(`Does "${tokenName}" match "${result.item.filename}":`)) {
                console.log(""); // add new line
                return result.item;
            }
        }
    }

    throw Error(`Can't find character image for "${tokenName}"`);

}

function searchForReminderImages(fuse: Fuse<ImageEntry>, tokenName: string): ImageEntry[] {
    const searchResults = fuse.search(tokenName, { limit: 8 });
    const correctResults: ImageEntry[] = [];

    let printedMessages = false;

    for (let i = 0; i < searchResults.length; i++) {
        const result = searchResults[i];

        // check if result needs to be confirmed by the user
        if ((result.score ?? 0) < fuseConfirmWithUserThreshold) {
            correctResults.push(result.item); // safe match
        } else {
            // confirm with user on dubious matches
            printedMessages = true;
            if (confirm(`Does "${tokenName}" match "${result.item.filename}":`)) {
                correctResults.push(result.item);
            } else {
                break;
            }
        }
    }

    if (printedMessages)
        console.log(""); // add new line

    return correctResults;
}

async function loadImage(path: string): Promise<ImageBitmap> {
    const bytes = await Deno.readFile(path);
    const blob = new Blob([bytes], { type: "image/png" });
    return createImageBitmap(blob);
}

function printSummary(script: ScriptSkeletonWithImages) {
    console.log(`### ${script.title} by ${script.author} ###`)

    for (const token of script.tokens) {
        if (token.reminderImages.length > 0) {
            console.log(`${token.name} with ${token.reminderImages.length} reminder types(s)`);
        } else {
            console.log(`${token.name}`);
        }
    }

    console.log("");
    if (!confirm("Is this correct?"))
        throw Error("Summary is incorrect");
    console.log("");
}

function promptScriptCounts(script: Script<Partial<Token>>) {
    for (const token of script.tokens) {
        token.characterCount = promptPositiveInt(`${token.name} character tokens:`, 1);
        token.reminderCount = promptPositiveInt(`${token.name} reminders per type:`, 1);
    }
}

function promptPositiveInt(message?: string, _default?: number) {
    // repeat prompt until something valid is entered
    let number;
    do {
        number = Number(prompt(message, String(_default)))
        if (number !== Math.trunc(number)) continue;
        if (number < 0) continue;
    } while (isNaN(number));

    return number;
}