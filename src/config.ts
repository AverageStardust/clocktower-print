// @deno-types="https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.d.ts"
import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.mjs';
import * as path from "https://deno.land/std@0.224.0/path/mod.ts";
import { mimelite } from "https://deno.land/x/mimetypes@v1.0.0/mod.ts"

import { printError, printWarning } from './logging.ts';

enum TokenType {
    Character = "character",
    Reminder = "reminder"
}

export interface Config {
    script: Script<Token>;

    characterPrintRadius: number;
    characterCutRadius: number;

    reminderPrintRadius: number;
    reminderCutRadius: number;

    pageWidth: number;
    pageHeight: number;
    pageDpi: number;
}

export interface Script<T> {
    title: string;
    author: string;
    tokens: T[];
}

export interface Token {
    name: string;
    isOffical: boolean;
    characterImagePath: string;
    reminderImagePaths: string[];
    characterCount: number;
    reminderCounts: number[];
}

interface ImageEntry {
    filepath: string;
    filename: string;
    searchString: string;
    isOffical: boolean | null;
}

type ScriptSkeleton = Script<Partial<Token> & {
    name: string,
    isOffical: boolean
}>;
type ScriptSkeletonWithPaths = Script<Partial<Token> & {
    name: string,
    isOffical: boolean,
    characterImagePath: string,
    reminderImagePaths: string[],
    characterImageMime: string,
    reminderImageMimes: string[]
}>;

const fuseConfirmWithUserThreshold = 0.2;
const fuseOptions = {
    isCaseSensitive: false,
    includeScore: true,
    threshold: 0.4,
    keys: [
        "searchString",
    ]
};

const decoder = new TextDecoder();

export async function promptConfig(): Promise<Config> {
    const config: Partial<Config> = {};


    config.script = await promptScript();

    config.characterPrintRadius = 51.3;
    config.characterCutRadius = 45;

    config.reminderPrintRadius = 28;
    config.reminderCutRadius = 25;

    config.pageWidth = 210; // A4 width
    config.pageHeight = 279.4; // Letter paper height

    config.pageDpi = 300;

    return config as Config;
}

async function promptScript(): Promise<Script<Token>> {
    let skeleton = undefined;
    while (skeleton === undefined) {
        const filePath = prompt("Where is the script file:");

        // repeat prompt until something is entered
        if (filePath === null) continue;

        // parse script
        try {
            const bytes = await Deno.readFile(filePath);
            const text = decoder.decode(bytes);
            const json = JSON.parse(text);
            skeleton = parseScriptSkeleton(json);
        } catch (err) {
            // error and try again
            printError(String(err));
        }

        console.log(""); // add new line
    }


    const skeletonWithPaths = addScriptImagePaths(skeleton);
    const script = addScriptCounts(skeletonWithPaths);

    return script;
}

function parseScriptSkeleton(obj: unknown): ScriptSkeleton {
    const script: Partial<Script<Partial<Token>>> = {};
    script.tokens = [];

    if (!Array.isArray(obj))
        throw Error("Invalid script: script not an array");

    for (const tag of obj) {

        // handle weird format generated by ivory clocktower
        if (typeof tag == "string") {
            if (checkIfMagicString(tag)) continue;
            script.tokens.push({ name: tag, isOffical: true });
            continue;
        }

        if (typeof tag !== "object")
            throw Error("Invalid script: tag not a object");

        const id = tag.id;
        if (typeof id !== "string")
            throw Error("Invalid script: id is not a string");

        script.author = "unknown";
        script.title = "untitled";
        switch (id) {
            case "_meta":
                // parse meta tag
                if (typeof tag.author === "string")
                    script.author = tag.author
                if (typeof tag.name === "string")
                    script.title = tag.name

                break;
            default: {
                if (checkIfMagicString(id)) break;

                // parse token tag
                if (tag.name !== undefined) {
                    script.tokens.push({ name: String(tag.name), isOffical: false });
                } else {
                    // offical tokens will likely only have an id
                    script.tokens.push({ name: id, isOffical: true });
                }
            } break;
        }
    }

    if (script.tokens.length <= 0)
        printWarning("Warning: Zero tokens found in script");

    return script as ScriptSkeleton;
}

function checkIfMagicString(str: string) {
    if (str.startsWith("_")) {
        printWarning(`Warning: Unknown magic string "${str}"`);
        return true;
    }

    return false;
}

function addScriptImagePaths(script: ScriptSkeleton): ScriptSkeletonWithPaths {
    addScriptImagePathsForType(script, TokenType.Character);
    addScriptImagePathsForType(script, TokenType.Reminder);
    return script as ScriptSkeletonWithPaths;
}

function addScriptImagePathsForType(script: ScriptSkeleton, tokenType: TokenType) {
    const imageEntries = promptImageEntriesFromDir(`Where are the ${tokenType} images:`);

    const fuseOffical = new Fuse(imageEntries.filter(
        ({ isOffical }) => isOffical !== false), // filter to get only official and unknown status
        fuseOptions);

    const fuseUnoffical = new Fuse(imageEntries.filter(
        ({ isOffical }) => isOffical !== true), // filter to get only unofficial and unknown status
        fuseOptions);

    for (const token of script.tokens) {
        const fuse = token.isOffical ? fuseOffical : fuseUnoffical;

        let entries: ImageEntry[];
        switch (tokenType) {
            case TokenType.Character:
                entries = searchForImages(fuse, token.name, 1, 1, 4);
                break;
            case TokenType.Reminder:
                entries = searchForImages(fuse, token.name, 0, 8, 8);
                break;
        }

        const imagePaths = entries.map(({ filepath }) => filepath);

        switch (tokenType) {
            case TokenType.Character:
                token.characterImagePath = imagePaths[0];
                break;
            case TokenType.Reminder:
                token.reminderImagePaths = imagePaths;
                break;
        }
    }
}

function promptImageEntriesFromDir(message?: string, _default?: string) {
    const imageEntries: ImageEntry[] = [];

    let folderPath = null, dirEntries = undefined;
    while (dirEntries === undefined || folderPath === null) {
        try {
            // repeat prompt until something is entered
            folderPath = prompt(message, _default);
            if (folderPath === null) continue;

            dirEntries = Deno.readDirSync(folderPath);
        } catch (err) {
            // error and try again
            printError(String(err));
        }
        console.log(""); // add new line
    }

    for (const dirEntry of dirEntries) {
        const imageEntry = parseImageEntryFromDir(dirEntry, folderPath);
        if (imageEntry !== null)
            imageEntries.push(imageEntry);
    }

    return imageEntries;
}

function parseImageEntryFromDir(dirEntry: Deno.DirEntry, folderPath: string): ImageEntry | null {
    if (!dirEntry.isFile) return null;

    const mimeType = mimelite.getType(dirEntry.name);
    if (mimeType === undefined || mimeType!.startsWith("image/")) return null;

    let searchString = dirEntry.name;

    // remove file extensions
    const searchStringParts = searchString.split(".");
    if (searchStringParts.length > 1) searchStringParts.pop(); // remove file extension
    searchString = searchStringParts.join(".");

    // try to remove all but first phrase
    if (searchString.includes("_")) {
        // select first phrase by seperating underscores underscores
        searchString = searchString.split("_")[0];
    } else {
        const firstWord = searchString.split(" ")[0];
        const firstWordAllCaps = firstWord === firstWord.toUpperCase();
        const wholeStringAllCaps = searchString === searchString.toUpperCase();

        if (firstWordAllCaps && !wholeStringAllCaps) {
            // select first phrase by seperating all caps section
            searchString = searchString.replace(/[A-Za-z][a-z].+/, "").trimEnd();
        }
    }

    // remove spaces
    searchString = searchString.replaceAll(" ", "");

    let isOffical = null;
    if (name.toLowerCase().includes("unofficial")) {
        isOffical = false;
    } else if (name.toLowerCase().includes("official")) {
        isOffical = true
    }

    return {
        filepath: path.resolve(folderPath, dirEntry.name),
        filename: dirEntry.name,
        searchString,
        isOffical
    };
}

function searchForImages(fuse: Fuse<ImageEntry>, tokenName: string, minResults: number, maxResults: number, attemptedResults: number): ImageEntry[] {
    const searchResults = fuse.search(tokenName, { limit: attemptedResults });
    const correctResults: ImageEntry[] = [];

    let printedMessages = false;

    for (let i = 0; i < searchResults.length; i++) {
        const result = searchResults[i];

        // check if result needs to be confirmed by the user
        if ((result.score ?? 0) < fuseConfirmWithUserThreshold) {
            correctResults.push(result.item); // safe match

            // we have hit the max number results, stop asking
            if (correctResults.length >= maxResults) break;
        } else {
            // confirm with user on dubious matches
            printedMessages = true;
            if (confirm(`Does ${tokenName} match "${result.item.filename}":`)) {
                correctResults.push(result.item);

                // we have hit the max number results, stop asking
                if (correctResults.length >= maxResults) break;
            } else {
                // we have enough results and the rest seem bad, stop asking
                if (correctResults.length >= minResults) break;
            }
        }
    }

    if (printedMessages)
        console.log(""); // add new line

    return correctResults;
}

function addScriptCounts(script: ScriptSkeletonWithPaths): Script<Token> {
    for (const token of script.tokens) {
        token.characterCount = promptPositiveInt(`${token.name} character tokens:`, 1);
        token.reminderCounts = [];
        for (const reminderPath of token.reminderImagePaths) {
            const reminderFilename = path.basename(reminderPath);
            token.reminderCounts.push(promptPositiveInt(`"${reminderFilename}" reminder tokens:`, 1));
        }
    }

    return script as Script<Token>;
}

function promptPositiveInt(message?: string, _default?: number) {
    // repeat prompt until something valid is entered
    let number;
    do {
        number = Number(prompt(message, String(_default)))
        if (number !== Math.trunc(number)) continue;
        if (number < 0) continue;
    } while (isNaN(number));

    return number;
}