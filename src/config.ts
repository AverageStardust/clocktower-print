// @deno-types="https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.d.ts"
import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@7.1.0/dist/fuse.mjs';
import * as path from "https://deno.land/std@0.224.0/path/mod.ts";
import { mimelite } from "https://deno.land/x/mimetypes@v1.0.0/mod.ts"

import { printError, printWarning } from './logging.ts';

enum TokenType {
    Character = "character",
    Reminder = "reminder"
}

export interface Config {
    title: string;

    scripts: Script<Token>[];
    totalCount: number;

    cutWidth: number;

    characterPrintRadius: number;
    characterCutRadius: number;

    reminderPrintRadius: number;
    reminderCutRadius: number;

    pageWidth: number;
    pageHeight: number;
    pageDpi: number;
}

export interface Script<T> {
    title: string;
    author: string;
    tokens: T[];
    totalCount: number;
}

export interface Token {
    name: string;
    isOffical: boolean;
    characterImagePath: string;
    reminderImagePaths: string[];
    characterCount: number;
    reminderCounts: number[];
}

interface ImageEntry {
    filepath: string;
    filename: string;
    searchString: string;
    isOffical: boolean | null;
}

type ScriptSkeleton = Script<Partial<Token> & {
    name: string,
    isOffical: boolean
}>;
type ScriptSkeletonWithPaths = Script<Partial<Token> & {
    name: string,
    isOffical: boolean,
    characterImagePath: string,
    reminderImagePaths: string[]
}>;

const fuseConfirmWithUserThreshold = 0.2;
const fuseIgnoreThreshold = 0.4;
const fureDifferentLengthBias = 0.04;

const decoder = new TextDecoder();

export async function promptConfig(): Promise<Config> {
    const config: Partial<Config> = {};

    config.scripts = [];
    config.totalCount = 0;

    let collectingScripts = true;
    while (collectingScripts) {
        // add script
        const script = await promptScript();
        config.scripts.push(script);
        config.totalCount += script.totalCount;

        collectingScripts = confirm("Add another script?");
        console.log(""); // add new line
    }

    // repeat prompt until something is entered
    while (config.title === undefined || config.title.length === 0)
        config.title = prompt("Output title:", "untitled") ?? undefined;

    config.cutWidth = promptPositiveFloat("Cut width in mm:", 0.1);

    config.characterPrintRadius = 51.3 / 2;
    config.characterCutRadius = 45 / 2;

    config.reminderPrintRadius = 28 / 2;
    config.reminderCutRadius = 25 / 2;

    config.pageWidth = 210; // A4 width
    config.pageHeight = 279.4; // Letter paper height

    config.pageDpi = 300;

    return config as Config;
}

async function promptScript(): Promise<Script<Token>> {
    let skeleton = undefined;
    while (skeleton === undefined) {
        const filePath = prompt("Where is the script file:");

        // repeat prompt until something is entered
        if (filePath === null) continue;

        // parse script
        try {
            const bytes = await Deno.readFile(filePath);
            const text = decoder.decode(bytes);
            const json = JSON.parse(text);
            skeleton = parseScriptSkeleton(json);
        } catch (err) {
            // error and try again
            printError(String(err));
        }

        console.log(""); // add new line
    }


    const skeletonWithPaths = addScriptImagePaths(skeleton);
    const script = addScriptCounts(skeletonWithPaths);

    return script;
}

function parseScriptSkeleton(obj: unknown): ScriptSkeleton {
    const script: Partial<Script<Partial<Token>>> = {};
    script.tokens = [];

    if (!Array.isArray(obj))
        throw Error("Invalid script: script not an array");

    for (const tag of obj) {

        // handle weird format generated by ivory clocktower
        if (typeof tag == "string") {
            if (checkIfMagicString(tag)) continue;
            script.tokens.push({ name: tag, isOffical: true });
            continue;
        }

        if (typeof tag !== "object")
            throw Error("Invalid script: tag not a object");

        const id = tag.id;
        if (typeof id !== "string")
            throw Error("Invalid script: id is not a string");

        switch (id) {
            case "_meta":
                // parse meta tag
                if (typeof tag.author === "string")
                    script.author = tag.author
                if (typeof tag.name === "string")
                    script.title = tag.name

                break;
            default: {
                if (checkIfMagicString(id)) break;

                // parse token tag
                if (tag.name !== undefined) {
                    script.tokens.push({ name: String(tag.name), isOffical: false });
                } else {
                    // offical tokens will likely only have an id
                    script.tokens.push({ name: id, isOffical: true });
                }
            } break;
        }
    }

    if (script.tokens.length <= 0)
        printWarning("Warning: Zero tokens found in script");

    // repeat prompt until something is entered
    while (script.author === undefined || script.author.length === 0)
        script.author = prompt("Script author:", "unknown") ?? undefined;

    // repeat prompt until something is entered
    while (script.title === undefined || script.title.length === 0)
        script.title = prompt("Script title:", "untitled") ?? undefined;

    script.author = script.author.trim();
    script.title = script.title.trim();

    return script as ScriptSkeleton;
}

function checkIfMagicString(str: string) {
    if (str.startsWith("_")) {
        printWarning(`Warning: Unknown magic string "${str}"`);
        return true;
    }

    return false;
}

function addScriptImagePaths(script: ScriptSkeleton): ScriptSkeletonWithPaths {
    addScriptImagePathsForTypeWithErrorHandling(script, TokenType.Character);
    addScriptImagePathsForTypeWithErrorHandling(script, TokenType.Reminder);
    return script as ScriptSkeletonWithPaths;
}

function addScriptImagePathsForTypeWithErrorHandling(script: ScriptSkeleton, tokenType: TokenType) {
    while (true) {
        try {
            addScriptImagePathsForType(script, tokenType);
            return;
        } catch (error) {
            printError(String(error));
        }
    }
}

function addScriptImagePathsForType(script: ScriptSkeleton, tokenType: TokenType) {
    const imageEntries = promptImageEntriesFromDir(`Where are the ${tokenType} images:`);

    const options = {
        isCaseSensitive: false,
        includeScore: true,
        threshold: fuseIgnoreThreshold,
        keys: [
            "searchString",
        ]
    };;

    const fuseOffical = new Fuse(imageEntries.filter(
        ({ isOffical }) => isOffical !== false), // filter to get only official and unknown status
        options);

    const fuseUnoffical = new Fuse(imageEntries.filter(
        ({ isOffical }) => isOffical !== true), // filter to get only unofficial and unknown status
        options);

    for (const token of script.tokens) {
        const fuse = token.isOffical ? fuseOffical : fuseUnoffical;

        let entries: ImageEntry[];
        switch (tokenType) {
            case TokenType.Character:
                entries = searchForImages(fuse, token.name, 1, 1, 4);
                break;
            case TokenType.Reminder:
                entries = searchForImages(fuse, token.name, 0, 8, 8);
                break;
        }

        const imagePaths = entries.map(({ filepath }) => filepath);

        switch (tokenType) {
            case TokenType.Character:
                token.characterImagePath = imagePaths[0];
                break;
            case TokenType.Reminder:
                token.reminderImagePaths = imagePaths.sort();
                break;
        }
    }
}

function promptImageEntriesFromDir(message?: string, _default?: string) {
    const imageEntries: ImageEntry[] = [];

    let folderPath = null, dirEntries = undefined;
    while (dirEntries === undefined || folderPath === null) {
        try {
            // repeat prompt until something is entered
            folderPath = prompt(message, _default);
            if (folderPath === null) continue;

            dirEntries = Deno.readDirSync(folderPath);
        } catch (err) {
            // error and try again
            printError(String(err));
        }
        console.log(""); // add new line
    }

    for (const dirEntry of dirEntries) {
        const imageEntry = parseImageEntryFromDir(dirEntry, folderPath);
        if (imageEntry !== null)
            imageEntries.push(imageEntry);
    }

    return imageEntries;
}

function parseImageEntryFromDir(dirEntry: Deno.DirEntry, folderPath: string): ImageEntry | null {
    if (!dirEntry.isFile) return null;

    const mimeType = mimelite.getType(dirEntry.name);
    if (mimeType === undefined || !mimeType.startsWith("image/")) return null;

    let searchString = dirEntry.name;

    // remove file extensions
    const searchStringParts = searchString.split(".");
    if (searchStringParts.length > 1) searchStringParts.pop(); // remove file extension
    searchString = searchStringParts.join(".");

    // try to remove all but first phrase
    if (searchString.includes("_")) {
        // select first phrase by seperating underscores underscores
        searchString = searchString.split("_")[0];
    } else {
        const firstWord = searchString.split(" ")[0];
        const firstWordAllCaps = firstWord === firstWord.toUpperCase();
        const wholeStringAllCaps = searchString === searchString.toUpperCase();

        if (firstWordAllCaps && !wholeStringAllCaps) {
            // select first phrase by seperating all caps section
            searchString = searchString.replace(/[A-Za-z][a-z].+/, "").trimEnd();
        }
    }

    // remove spaces
    searchString = searchString.replaceAll(" ", "");

    let isOffical = null;
    if (name.toLowerCase().includes("unofficial")) {
        isOffical = false;
    } else if (name.toLowerCase().includes("official")) {
        isOffical = true
    }

    return {
        filepath: path.resolve(folderPath, dirEntry.name),
        filename: dirEntry.name,
        searchString,
        isOffical
    };
}

function searchForImages(fuse: Fuse<ImageEntry>, tokenName: string, minResults: number, maxResults: number, attemptedResults: number): ImageEntry[] {
    let searchResults = fuse.search(tokenName, { limit: attemptedResults }) as {
        item: ImageEntry
        score: number
    }[];
    const correctResults: ImageEntry[] = [];

    let printedMessages = false;

    // ajust scores for string length differance
    for (const result of searchResults) {
        const lengthDifferance = Math.abs(result.item.searchString.length - tokenName.length);
        result.score = result.score + lengthDifferance * fureDifferentLengthBias;
    }

    searchResults = searchResults
        .sort((result) => result.score)
        .filter((result) => result.score <= fuseIgnoreThreshold);

    for (const { item, score } of searchResults) {

        // check if result needs to be confirmed by the user
        if (score < fuseConfirmWithUserThreshold) {
            correctResults.push(item); // safe match

            // we have hit the max number results, stop asking
            if (correctResults.length >= maxResults) break;
        } else {
            // confirm with user on dubious matches
            printedMessages = true;
            if (confirm(`Does "${tokenName}" match "${item.filename}"?`)) {
                correctResults.push(item);

                // we have hit the max number results, stop asking
                if (correctResults.length >= maxResults) break;
            } else {
                // we have enough results and the rest seem bad, stop asking
                if (correctResults.length >= minResults) break;
            }
        }
    }

    if (correctResults.length < minResults)
        throw Error(`Couldn't find image for ${tokenName}`);

    if (printedMessages)
        console.log(""); // add new line

    return correctResults;
}

function addScriptCounts(script: ScriptSkeletonWithPaths): Script<Token> {
    let totalCount = 0;

    for (const token of script.tokens) {
        token.characterCount = promptPositiveOrZeroInt(`${token.name} character tokens:`, 1);
        totalCount += token.characterCount;

        token.reminderCounts = [];
        for (const reminderPath of token.reminderImagePaths) {
            const reminderFilename = path.basename(reminderPath);
            const reminderCount = promptPositiveOrZeroInt(`"${reminderFilename}" reminder tokens:`, 1);
            token.reminderCounts.push(reminderCount);
            totalCount += reminderCount;
        }
    }

    console.log(""); // add new line

    script.totalCount = totalCount;

    return script as Script<Token>;
}

function promptPositiveFloat(message?: string, _default?: number) {
    // repeat prompt until something valid is entered
    let number;
    do {
        number = Number(prompt(message, String(_default)))
        if (number <= 0) continue;
    } while (isNaN(number));

    return number;
}

function promptPositiveOrZeroInt(message?: string, _default?: number) {
    // repeat prompt until something valid is entered
    let number;
    do {
        number = Number(prompt(message, String(_default)))
        if (number !== Math.trunc(number)) continue;
        if (number < 0) continue;
    } while (isNaN(number));

    return number;
}